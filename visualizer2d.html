<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Datacenter Physical View (2D)</title>
    <style>
        body { margin: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f0f2f5; color: #333; }
        .header { padding: 20px; background: #fff; border-bottom: 1px solid #ddd; display: flex; align-items: center; justify-content: space-between; }
        h1 { margin: 0; font-size: 24px; color: #2c3e50; }
        .instructions { font-size: 14px; color: #666; }
        input[type="file"] { margin-left: 20px; }
        
        #datacenter-view {
            display: flex;
            padding: 40px;
            overflow-x: auto;
            position: relative;
            min-height: 900px;
        }

        .rack-container {
            margin-right: 100px;
            position: relative;
            z-index: 2; /* Above cables */
        }

        .rack-label {
            text-align: center;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 18px;
            background: #2c3e50;
            color: #fff;
            padding: 5px;
            border-radius: 4px;
        }

        .rack-frame {
            width: 300px;
            height: 840px; /* 42U * 20px */
            background: #e0e0e0;
            border: 4px solid #444;
            position: relative;
            box-shadow: 5px 5px 15px rgba(0,0,0,0.2);
            background-image: linear-gradient(#ccc 1px, transparent 1px);
            background-size: 100% 20px; /* 1U lines */
        }

        .u-marker {
            position: absolute;
            left: -25px;
            width: 20px;
            text-align: right;
            font-size: 10px;
            color: #888;
            height: 20px;
            line-height: 20px;
        }

        .device {
            position: absolute;
            left: 2px;
            right: 2px;
            background: #3498db;
            border: 1px solid #2980b9;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 12px;
            overflow: hidden;
            border-radius: 2px;
            cursor: pointer;
            transition: transform 0.1s;
        }
        .device:hover { transform: scale(1.02); z-index: 10; box-shadow: 0 0 10px rgba(0,0,0,0.3); }
        .device.switch { background: #27ae60; border-color: #219150; }
        .device.pdu { background: #e67e22; border-color: #d35400; width: 30px; right: -35px; left: auto; height: 100%; writing-mode: vertical-rl; }

        .device-info { font-size: 10px; text-align: center; pointer-events: none; }
        .device-serial { font-weight: bold; display: block; }
        .device-model { font-size: 9px; opacity: 0.9; }

        /* SVG Layer for Cables */
        #cable-layer {
            position: absolute;
            top: 40px; /* Offset by padding */
            left: 40px;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1; /* Behind racks */
        }
        path.cable {
            fill: none;
            stroke-opacity: 0.6;
            transition: stroke-opacity 0.2s, stroke-width 0.2s;
        }
        path.cable:hover { stroke-opacity: 1.0; stroke-width: 4px; z-index: 99; cursor: pointer; }

        #tooltip {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: #fff;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 100;
        }
    </style>
</head>
<body>

<div class="header">
    <div>
        <h1>Datacenter Physical Visualizer (2D)</h1>
        <div class="instructions">Select <b>layer0.json</b> only.</div>
    </div>
    <input type="file" id="fileInput" accept=".json">
</div>

<div id="datacenter-view">
    <svg id="cable-layer"></svg>
    <!-- Racks will be injected here -->
</div>
<div id="tooltip"></div>

<script>
    const fileInput = document.getElementById('fileInput');
    const view = document.getElementById('datacenter-view');
    const cableLayer = document.getElementById('cable-layer');
    const tooltip = document.getElementById('tooltip');

    const U_HEIGHT = 20; // Pixels per Rack Unit

    fileInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const text = await file.text();
        try {
            const data = JSON.parse(text);
            if (data.datacenter) {
                renderDatacenter(data.datacenter);
            } else {
                alert("Invalid format. Please select layer0.json");
            }
        } catch (err) {
            console.error(err);
            alert("Error parsing JSON");
        }
    });

    // Map to store DOM elements of devices for cabling
    const deviceMap = new Map(); 

    function renderDatacenter(dc) {
        // Clear previous
        view.innerHTML = '<svg id="cable-layer"></svg>'; 
        const svg = document.getElementById('cable-layer');
        deviceMap.clear();

        dc.racks.forEach(rack => {
            const rackEl = document.createElement('div');
            rackEl.className = 'rack-container';
            
            const label = document.createElement('div');
            label.className = 'rack-label';
            label.textContent = rack.id;
            rackEl.appendChild(label);

            const frame = document.createElement('div');
            frame.className = 'rack-frame';
            // Set height based on rack units
            frame.style.height = (rack.totalUnits * U_HEIGHT) + 'px';
            
            // Render U Markers
            for (let i = 1; i <= rack.totalUnits; i++) {
                if (i % 5 === 0 || i === 1 || i === rack.totalUnits) {
                    const m = document.createElement('div');
                    m.className = 'u-marker';
                    m.textContent = i;
                    // Position from bottom
                    m.style.bottom = ((i-1) * U_HEIGHT) + 'px';
                    frame.appendChild(m);
                }
            }

            // Render Devices (Machines)
            if (rack.machines) {
                rack.machines.forEach(m => renderDevice(m, frame, 'machine'));
            }
            // Render Devices (Switches)
            if (rack.switches) {
                rack.switches.forEach(s => renderDevice(s, frame, 'switch'));
            }

            rackEl.appendChild(frame);
            view.appendChild(rackEl);
        });

        // Resize SVG to match container
        svg.style.width = view.scrollWidth + 'px';
        svg.style.height = view.scrollHeight + 'px';

        // Render Cables
        if (dc.cabling) {
            renderCables(dc.cabling, svg);
        }
    }

    function renderDevice(slotObj, container, type) {
        const dev = slotObj.device;
        const uPos = slotObj.slotIndex;
        // Default height 1U if not specified (Switches usually 1U in this model)
        const heightU = dev.heightU || 1; 

        const el = document.createElement('div');
        el.className = `device ${type}`;
        el.style.height = (heightU * U_HEIGHT - 4) + 'px'; // -4 for border/margin
        // Position: 1U starts at bottom. 
        // slotIndex 1 means bottom 20px. 
        // top = containerHeight - (uPos * U_HEIGHT)
        // Wait, slotIndex usually means the bottom-most U occupied? Or top? 
        // Convention: slotIndex is the starting U from bottom.
        // So bottom = (uPos - 1) * U_HEIGHT
        el.style.bottom = ((uPos - 1) * U_HEIGHT + 2) + 'px';
        
        el.innerHTML = `
            <div class="device-info">
                <span class="device-serial">${dev.serial}</span>
                <span class="device-model">${dev.model || dev.vendor}</span>
            </div>
        `;

        el.title = JSON.stringify(dev, null, 2); // Simple tooltip
        
        container.appendChild(el);
        
        // Store center point relative to the view for cabling
        // Need to wait for layout? No, we can calculate based on Rack position.
        // We'll do it lazily or calculate in renderCables.
        // Actually, getting bounding rect is easier after append.
        deviceMap.set(dev.serial, el);
    }

    function renderCables(cables, svg) {
        // Need to ensure elements are layout
        // Use timeout 0 to let DOM render
        setTimeout(() => {
            const svgRect = svg.getBoundingClientRect();

            cables.forEach(link => {
                const srcEl = deviceMap.get(link.linkEndpointA.cpDeviceSerial);
                const dstEl = deviceMap.get(link.linkEndpointB.cpDeviceSerial);

                if (srcEl && dstEl) {
                    const srcRect = srcEl.getBoundingClientRect();
                    const dstRect = dstEl.getBoundingClientRect();

                    // Calculate center points relative to SVG
                    const x1 = srcRect.left + srcRect.width / 2 - svgRect.left;
                    const y1 = srcRect.top + srcRect.height / 2 - svgRect.top;
                    const x2 = dstRect.left + dstRect.width / 2 - svgRect.left;
                    const y2 = dstRect.top + dstRect.height / 2 - svgRect.top;

                    // Draw Path
                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    
                    // Bezier Curve Logic
                    // Go out horizontally or vertically?
                    // Typically cables go to side of rack. 
                    // Let's emulate side routing.
                    // Find which rack they are in.
                    // Simple logic: Control points high above or to the side.
                    // Let's use simple vertical arching if different racks, or side loop if same rack.
                    
                    const deltaX = Math.abs(x2 - x1);
                    const deltaY = Math.abs(y2 - y1);
                    
                    let d = "";
                    if (deltaX < 50) {
                        // Same rack or close: Loop to side
                        const cpX = x1 + 150; // Curve out to right
                        d = `M ${x1} ${y1} C ${cpX} ${y1}, ${cpX} ${y2}, ${x2} ${y2}`;
                    } else {
                        // Different rack: Arch over top? Or direct?
                        // Arching looks cleaner for "cables going out".
                        // Use top of racks (y approx 40px) as channel.
                        const rackTop = 50; 
                        d = `M ${x1} ${y1} C ${x1} ${y1 - 100}, ${x2} ${y2 - 100}, ${x2} ${y2}`;
                        // Or better: go up to ceiling, across, down.
                        // d = `M ${x1} ${y1} L ${x1} ${rackTop} L ${x2} ${rackTop} L ${x2} ${y2}`;
                        // Let's use a nice curve.
                    }

                    // Adjust control points for smoother look
                    const cpY = Math.min(y1, y2) - 100;
                    d = `M ${x1} ${y1} C ${x1} ${cpY}, ${x2} ${cpY}, ${x2} ${y2}`;

                    path.setAttribute("d", d);
                    path.setAttribute("class", "cable");
                    
                    // Color
                    let color = "#999";
                    if (link.linkCableType === "FiberOM4") color = "#e056fd";
                    else if (link.linkCableType === "Twinax_DAC") color = "#333";
                    
                    path.setAttribute("stroke", color);
                    path.setAttribute("stroke-width", "2");

                    // Tooltip
                    path.addEventListener('mousemove', (e) => {
                        tooltip.style.display = 'block';
                        tooltip.style.left = e.pageX + 10 + 'px';
                        tooltip.style.top = e.pageY + 10 + 'px';
                        tooltip.innerHTML = `<b>${link.linkId}</b><br>${link.linkCableType}`;
                    });
                    path.addEventListener('mouseout', () => {
                        tooltip.style.display = 'none';
                    });

                    svg.appendChild(path);
                }
            });
        }, 100);
    }
</script>
</body>
</html>
